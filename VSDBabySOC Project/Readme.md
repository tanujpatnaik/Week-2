## Step-by-step Guide for Set-up and Simulation


<details>
  <summary>RVMYTH</summary

- First clone the Github Repository (https://github.com/kunalg123/rvmyth/)

```bash
git clone https://github.com/kunalg123/rvmyth/
```


### RISC-V MYTH CORE

- Simulate the **RVMYTH core** using **IVerilog**.

- Observe and analyse the Waveforms using **GTKWave**.


```bash
iverilog mythcore_test.v tb_mythcore_test.v
./a.out
gtkwave tb_mythcore_test.vcd
```



![WhatsApp Image 2025-10-04 at 16 59 07_2e51d8e5](https://github.com/user-attachments/assets/39123883-edad-45da-b522-dc97e5aea4a9)




### Waveform Analysis


![WhatsApp Image 2025-10-04 at 17 02 21_f0259069](https://github.com/user-attachments/assets/931209f9-0a5e-4857-81f5-ae9c76062cd0)

- **Signals in the waveform**

   - `clk` ‚Üí The clock is running at a constant frequency (high-frequency toggling, as expected).

   - `reset` ‚Üí Held low (0), so the core is out of reset and running normally.

   - `out[9:0]` ‚Üí This is the observed output bus of the RVMYTH core (10-bit wide).

- **Interpretation**

   - The waveform looks like a triangular / incremental-decremental sequence generated by the core. More specifically:
        - The values are counting down (0xA ‚Üí 0x6 ‚Üí 0x3 ‚Üí 0x1 ‚Üí 0x0),then counting up again (0x1 ‚Üí 0x3 ‚Üí 0x6 ‚Üí 0xA ‚Üí 0xF).
        
        - It demonstrates that the RVMYTH pipeline and ALU are working correctly (performing ADD/SUB operations to generate the sequence).
        
        - Since out[9:0] is only 10 bits wide, larger numbers are truncated, but here the values are small (within 0x00‚Äì0x0F range).


- **What it tells about the RVMYTH core**

   - The core is executing its sample program (typically a Fibonacci or triangular number generator loaded into instruction memory in the MYTH workshops).
   
   - The progression of values confirms:
        - Instruction fetch/decode/execute pipeline is functioning.
        
        - Register updates and ALU arithmetic are correct.
        
        - The output port is properly mapped to the program‚Äôs result register.

          
</details>


<details>
  <summary>VSDBabySoC</summary>

- Clone the Github Repository (https://github.com/manili/VSDBabySoC)

```bash
git clone https://github.com/manili/VSDBabySoC
cd VSDBabySoC
```


- Convert the RVMYTH TLV file to Verilog

```bash
# Tools Installation
sudo apt update
sudo apt install python3-venv python3-pip

# Create a virtual environment
python3 -m venv sp_env
source sp_env/bin/activate

# Install SandPiper-SaaS
pip install pyyaml click sandpiper-saas

# TLV ‚Üí Verilog
sandpiper-saas -i ./src/module/*.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/

```

- Make a directory where simulation output files will be stored.

```bash

mkdir -p output/pre_synth_sim

```

- Simulate the Testbench using **IVerilog**.

```bash

iverilog -o output/pre_synth_sim/pre_synth_sim.out \
  -DPRE_SYNTH_SIM \

## Add include search path for header files
  -I src/include -I src/module \

## Top-level verilog testbench to compile
  src/module/testbench.v

## Run the simulation executable
cd output/pre_synth_sim
./pre_synth_sim.out

```

- Analyze the waveforms in **GTKWave**.

```bash

gtkwave pre_synth_sim.vcd

```

### Waveform Analysis

<img width="1221" height="795" alt="Pre-synthesis Output waveform" src="https://github.com/user-attachments/assets/f201ec90-1f54-405c-9ee2-1d1ddd1286e9" />


Clock Signals

1.CLK and derived PLL clock signals are visible.

   - The PLL generates different frequency clocks (CLK_CP, refclk, vco_clk).

   - The yellow sinusoidal-looking signals represent analog-modelled PLL outputs (like VCO frequency              tracking, phase difference).

   - refclk vs vco show the phase comparison behavior.

   - As simulation progresses, the PLL locks (stable periodic waveform).

2.Reset (rst_n)

   - Initially, system reset is asserted (0).

   - Later released (1) to start the CPU execution.

3.CPU Signals

   - CPU_dmem_addr, CPU_dmem_ld_data etc. indicate instruction fetch and memory access.

   - You see binary activity (green toggling) ‚Üí CPU is fetching instructions and executing them.

   - CPU_dmem_rd_data toggles between values like 0x31, 0x00000001 etc., confirming proper instruction flow.

4.PLL Behavior

   - vco_freq and refpd (phase difference) are plotted.

   - Initially, VCO frequency is unstable (nan values), then it converges (~759.01 MHz).

   - refpd converges to a small error, showing PLL locked condition.

5.Output Signals

   - OUT (from CPU or SoC testbench) shows data values (946, etc.).

   - This indicates the RISC-V core completed execution of its program and produced outputs.

### üîç Observations

- PLL Locking: The yellow sinusoidal signals (VCO vs ref) show the PLL gradually reaching lock ‚Äî VCO frequency stabilizes.

- RISC-V Core Activity: Instruction/data signals toggling means CPU is running code correctly.

- Memory Interaction: CPU is actively fetching from memory (dmem signals change).

- Final Outputs: The OUT signal produces a numeric result, which means the SoC has executed the intended program successfully.

### üìñ Conclusion

This waveform confirms that:

- The PLL is locking properly (phase difference reduces, VCO stabilizes).

- The RVMyth RISC-V CPU is functional, fetching instructions and computing.

- SoC integration works ‚Äî clocking, memory, and CPU interaction are correct.

- The OUT values verify the test program ran to completion.

**Core Signals**

<img width="937" height="193" alt="core waveform" src="https://github.com/user-attachments/assets/555099a0-30eb-4836-a989-02c7f295b4ec" />

- Fetches instructions from memory and executes them.

- CPU is running instructions.

- The instruction flow is visible as memory accesses.

- Instruction memory contains:

| Clock | Instruction |
|-----|-------------|
| 0 | ADDI r9, r0, 1 |
| 1 | ADDI r10, r0, 101011 (decimal 43) |
| 2 | ADDI r11, r0, 0 |
| 3 | ADDI r17, r0, 0 |
| 4 | ADD r17, r17, r11 |
| 5 | ADDI r11, r11, 1 |
| 6 | BNE r11, r10, -8   (loop back) |
| 7 | ADD r17, r17, r11 |
| 8 | SUB r17, r17, r11 |
| 9 | SUB r11, r11, r9 |
| 10 | BNE r11, r9, -8 |
| 11 | SUB r17, r17, r11 |
| 12 |BEQ r0, r0, -16 (infinite loop) |


**PLL signals**

<img width="937" height="193" alt="pll waveform" src="https://github.com/user-attachments/assets/88d42504-60b0-4c04-9c5f-57f4fe2eccc7" />

- The PLL module in the design is a behavioral model that mimics the real analog PLL (which generates a higher-frequency clock for the CPU).

**DAC signals**


<img width="937" height="193" alt="dac waveform" src="https://github.com/user-attachments/assets/f0ff3af4-c120-4582-bf15-8131a8c2bb45" />

- `avsddac` converts this 10-bit digital value to an analog voltage.

- DAC Output Calculation

   - For a constant r17 value:
     OUT = (ùëü17/1023)*VREFH

   - Maximum value of 10-bit DAC: 1023 ‚Üí maps to VREFH.

- Output waveform: step function, rises from 0 ‚Üí r17/1023 * VREFH, then stays constant.

- No oscillation unless CPU loop modifies r17 continuously (here, final loop is infinite with no writes to r17 affecting DAC, so output is constant).

</details>


